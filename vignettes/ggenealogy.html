<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

  <head>

    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="pandoc" />

        <meta name="author" content="Lindsay Rutter, Susan Vanderplas, Di Cook" />
    
    
    <title>Getting started with the package phyViz</title>

        <script src="phyViz_files/jquery-1.11.0/jquery.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="phyViz_files/bootstrap3-3.2.0/css/bootstrap.min.css" rel="stylesheet" />
    <link href="phyViz_files/bootstrap3-3.2.0/css/themes/default/bootstrap.min.css" rel="stylesheet" />
    <script src="phyViz_files/bootstrap3-3.2.0/js/bootstrap.min.js"></script>
    <link href="phyViz_files/highlightjs-8.2/highlight/default.css" rel="stylesheet" />
    <script src="phyViz_files/highlightjs-8.2/highlight.pack.js"></script>
    <link href="phyViz_files/MagnificPopup-0.9.9/magnific-popup.css" rel="stylesheet" />
    <script src="phyViz_files/MagnificPopup-0.9.9/magnific-popup.js"></script>
    <link href="phyViz_files/knitrBootstrap-0.0.1/css/knitrBootstrap.css" rel="stylesheet" />
    <script src="phyViz_files/knitrBootstrap-0.0.1/js/knitrBootstrap.js"></script>
    
    
  </head>

  <body data-spy="scroll" data-target="#toc">
    <div id="wrapper" class="container">
      <div class="row">
        <div class="contents col-xs-12 col-md-12">

          
                    <div id="header">
            <h1 class="title">Getting started with the package <strong>phyViz</strong></h1>
                                                <h4 class="author"><em>Lindsay Rutter, Susan Vanderplas, Di Cook</em></h4>
                                              </div>
                    
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteDepends{knitr}
%\VignetteIndexEntry{phyViz: Phylogenetic Visualization}

-->
<p><strong>Description:</strong> The <strong>phyViz</strong> package provides tools to examine genealogical data, generating basic statistics on their graphical structures using parent and child connections, and displaying the results. The genealogy can be drawn in relation to additional variables, such as development year, and the shortest path distances between genetic lines can be determined and displayed. Production of pairwise distance matrices and phylogenetic diagrams constrained by generation count are also available in the visualization toolkit. This vignette is intended to walk readers through the different methods available with the package.</p><p><strong>Caution:</strong> igraph must be used with version &gt;= 0.7.1</p><div id="preprocessing-pipeline" class="section level1"><h1>Preprocessing Pipeline</h1><p>There is a preprocessing pipeline to follow before visualizing your genealogical data. First, you must load the necessary libraries. Note that loading the phyViz library should automatically load several dependent libraries (ggplot2, igraph, plyr, reshape2, stringr):</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">opts_chunk$set(tidy=T, results="hold", comment="#|")

library(phyViz)</code></pre></div></div><p>In the <strong>phyViz</strong> package, there is an example dataset containing genealogical information on soybean varieties called <strong>sbTree.rda</strong>. It may be helpful to load that example file so that you can follow along with the commands and options introduced in this vignette. To ensure that you have uploaded the correct, raw <strong>sbTree.rda</strong> file, you can observe the first six lines of it, and also determine its class type:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">data(sbTree)
head(sbTree)
class(sbTree)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#|           child year yield year.imputed    parent
#| 1         5601T 1981    NA         TRUE Hutcheson
#| 2         Adams 1948  2734        FALSE  Dunfield
#| 3          A.K. 1910    NA         TRUE      <NA>
#| 4 A.K. (Harrow) 1912  2665        FALSE      A.K.
#| 5        Altona 1968    NA        FALSE  Flambeau
#| 6         Amcor 1979  2981        FALSE  Amsoy 71
#| [1] "data.frame"
</code></pre></div></div><p>We see that the **sbTree* data file is a data frame structure with five variables per row. Each row contains a child node character label and parent node character label. Each row also contains a numeric value corresponding to the year the child node was introduced, an integer value of the protein yield of the child node, and a logical value whether or not the year of introduction of the child node was imputed.</p><p>Now that the sbTree file has been loaded as a data frame, it must now be converted into a graph object using the <strong>treeToIG()</strong> function. The <strong>treeToIG()</strong> function requires a data frame as input, and that data frame should be structured such that each row represents an edge with a child and parent relationship. For more information, try using the help command on the function:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">help(treeToIG)</code></pre></div></div><p>This allows you to view a more thorough description of the function arguments. For instance, we see that the function takes optional parameter arguments, such as <em>vertexinfo</em> (a list of columns of the data frame which provide information for the starting “child” vertex, or a separate data frame containing information for each vertex with the first column as the vertex name), <em>edgeweights</em> (a column that contains edge values, with a default value of unity), and <em>isDirected</em> (a boolean value that describes whether the graph is directed (true) or undirected (false); the default is false).</p><p>In this example, we want to produce an undirected graph object that contains all edge weight values of 1, because our goal is to set an edge value of unity for every pair of vertices (individuals) that are related as parent and child. The <strong>treeToIG()</strong> function uses the software <strong>igraph</strong> to convert the data frame into a graph object. For clarity, we will assign the outputted graph object the name <strong>ig</strong> (for igraph object), and then examine its class type:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">ig <- treeToIG(sbTree)
class(ig)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| [1] "igraph"
</code></pre></div></div><p>If successful, we can confirm that the <strong>ig</strong> object is of class type <strong>igraph</strong>.</p><p>We can add the other data we have about each of the nodes in <strong>ig</strong> in several ways. As we saw earlier, each row of the sbTree dataset contains information about each child. To append that data to the <strong>ig</strong> object, we can use the same command as before, but specify the <strong>vertexinfo</strong> parameter as follows:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">ig <- treeToIG(sbTree, vertexinfo = c("year", "yield", "year.imputed"))</code></pre></div></div><p>If we have separate data sets with node information, we can use that instead. For the example dataset, we must first obtain the node information:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">library(plyr)
nodes <- unique(sbTree[, 1:4])

# get a data frame of all parents whose parents are not known (i.e. parents who
# are not listed as children as well)
extra.nodes <- unique(data.frame(child = sbTree$parent[!sbTree$parent %in% sbTree$child & 
    !is.na(sbTree$parent)], stringsAsFactors = FALSE))

# We may not have information for these extra nodes, but they still need to be
# included in the dataset
nodes <- rbind.fill(nodes, extra.nodes)
rm(extra.nodes)

# We can now specify our vertex information using the data frame nodes:
ig <- treeToIG(sbTree, vertexinfo = nodes)</code></pre></div></div><p>The ig object is used in many of the other functions included with this package.</p></div><div id="functions-for-individual-vertices" class="section level1"><h1>Functions for Individual Vertices</h1><p>The <strong>phyViz</strong> package offers several functions that you can use to obtain information for individual vertices.</p><p>First, the function <strong>isParent()</strong> can return a logical variable to indicate whether or not the second variety is a parent of the first variety.</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">isParent("Young", "Essex", sbTree)
isParent("Essex", "Young", sbTree)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| [1] TRUE
#| [1] FALSE
</code></pre></div></div><p>We see that “Essex” is a parent of “Young”.</p><p>Similarly, the function <strong>isChild()</strong> can return a logical variable to indicate whether or not the first variety is a child of the second variety.</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">isChild("Young", "Essex", sbTree)
isChild("Essex", "Young", sbTree)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| [1] TRUE
#| [1] FALSE
</code></pre></div></div><p>We see that, as expected, “Young” is a child of “Essex”.</p><p>It is also possible to derive the year of a given variety using the <strong>getYear()</strong> function:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getYear("Young", sbTree)
getYear("Essex", sbTree)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| [1] 1968
#| [1] 1962
</code></pre></div></div><p>Fortunately, the returned year values are consistent, as the “Young” variety (1968) is a child to the “Essex” variety (1962) by an age difference of six years.</p><p>In some cases, you may wish to obtain a complete list of all the parents of a given variety. This can be achieved using the <strong>getParent()</strong> function:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getParent("Young", sbTree)
getParent("Tokyo", sbTree)
getYear("Tokyo", sbTree)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| [1] "Davis" "Essex"
#| character(0)
#| [1] 1907
</code></pre></div></div><p>We learn from this that “Essex” is not the only parent of “Young”; it also has a parent “Davis”. We also see that “Tokyo” does not have any documented parents in this dataset, and has an older year of introduction (1907) than other varieties we have examined thusfar.</p><p>Likewise, in other cases, you may wish to obtain a complete list of all the children of a given variety. This can be achieved using the <strong>getChild()</strong> function:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getChild("Tokyo", sbTree)
getChild("Ogden", sbTree)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| [1] "Ogden"    "Volstate"
#|  [1] "C1069"          "C1079"          "D51-2427"       "D55-4090"      
#|  [5] "D55-4159"       "D55-4168"       "Kent"           "N44-92"        
#|  [9] "N45-745"        "N48-1101"       "Ogden x CNS"    "Ralsoy x Ogden"
</code></pre></div></div><p>We find that even though the “Tokyo” variety is a grandparent of the dataset, it only has two children, “Ogden” and “Volstate”. However, one of its children, “Ogden”, produced twelve children.</p><p>If we want to obtain a list that contains more than just one generation past or previous to a given variety, then we can use the <strong>getAncestors()</strong> and <strong>getDescendants()</strong> functions, where we specify the number of generations we wish to view. This will return a data frame to us with the labels of each ancestor or descendant, along with the number of generations each one is from the given variety.</p><p>If we only look at one generation of ancestors of the “Young” variety, we should see the same information we did earlier when we used the <strong>getParent()</strong> function of the Young variety:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getAncestors("Young", sbTree, 1)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#|   label gen
#| 2 Davis   1
#| 1 Essex   1
</code></pre></div></div><p>Indeed, we consistently see that the “Young” variety has only two ancestors within one generation, “Davis” and “Essex”.</p><p>However, if we view the first five generations of ancestors of the “Young”&quot; variety, we can view four more generations of ancestors past simply the parents:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getAncestors("Young", sbTree, 5)
dim(getAncestors("Young", sbTree, 5))</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#|                      label gen
#| 27                   Davis   1
#| 26                   Essex   1
#| 25          Ralsoy x Ogden   2
#| 24 Roanoke x (Ogden x CNS)   2
#| 23                     Lee   2
#| 22                S55-7075   2
#| 21                   Ogden   3
#| 20                  Ralsoy   3
#| 19             Ogden x CNS   3
#| 17                     CNS   3
#| 18                 Roanoke   3
#| 16                   S 100   3
#| 15                N48-1248   3
#| 14                   Perry   3
#| 10                   Ogden   4
#| 13                PI 54610   4
#| 12                   Tokyo   4
#| 11                     CNS   4
#| 9                  Clemson   4
#| 6                  Roanoke   4
#| 8                   Illini   4
#| 7  N45-745 x (Ogden x CNS)   4
#| 4                 PI 54610   5
#| 3                    Tokyo   5
#| 1              Ogden x CNS   5
#| 5                  Clemson   5
#| 2                     A.K.   5
#| [1] 27  2
</code></pre></div></div><p>In the second line of code above, we determined the dimensions of the returned data frame, and see that there are 27 ancestors within the first five ancestral generations of the “Young” variety.</p><p>Similarly, if we only look at the first generation of descendants of the “Ogden”&quot; variety, we should see the same information as we did earlier when we used the <strong>getChild()</strong> function on the “Ogden” variety:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getDescendants("Ogden", sbTree, 1)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#|             label gen
#| 12          C1069   1
#| 11          C1079   1
#| 10       D51-2427   1
#| 9        D55-4090   1
#| 8        D55-4159   1
#| 7        D55-4168   1
#| 6            Kent   1
#| 5          N44-92   1
#| 4         N45-745   1
#| 3        N48-1101   1
#| 2     Ogden x CNS   1
#| 1  Ralsoy x Ogden   1
</code></pre></div></div><p>Indeed, we see again that “Ogden” has 12 children.</p><p>However, if we want to view not only the children, but also the grandchildren, of the “Ogden” variety, then we can use this function, only now specifying two generations of descendants:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getDescendants("Ogden", sbTree, 2)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#|                      label gen
#| 28                   C1069   1
#| 27                   C1079   1
#| 26                D51-2427   1
#| 25                D55-4090   1
#| 24                D55-4159   1
#| 23                D55-4168   1
#| 22                    Kent   1
#| 21                  N44-92   1
#| 20                 N45-745   1
#| 19                N48-1101   1
#| 18             Ogden x CNS   1
#| 17          Ralsoy x Ogden   1
#| 16                Columbus   2
#| 15                  Cutler   2
#| 14                  C1266R   2
#| 13                  Semmes   2
#| 11                D60-7965   2
#| 12                D60-7965   2
#| 10                D59-9289   2
#| 9                   Beeson   2
#| 8                  Calland   2
#| 7                     Hood   2
#| 6                 N48-1867   2
#| 5                  D52-810   2
#| 4  N45-745 x (Ogden x CNS)   2
#| 3                  R54-168   2
#| 2  Roanoke x (Ogden x CNS)   2
#| 1                    Davis   2
</code></pre></div></div><p>We see that variety “Ogden” has 16 grandchildren from its 12 children.</p></div><div id="functions-for-pairs-of-vertices" class="section level1"><h1>Functions for Pairs of Vertices</h1><p>Say you have a pair of vertices, and you wish to determine the degree of the shortest path between them, where edges represent parent-child relationships. You can accomplish that with the <strong>getDegree()</strong> function.</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getDegree("Tokyo", "Ogden", ig, sbTree)
getDegree("Tokyo", "Holladay", ig, sbTree)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| [1] 1
#| [1] 7
</code></pre></div></div><p>As expected, the shortest path between the “Tokyo” and “Ogden” varieties has a value of one, as we already determined that they have a direct parent-child relationship. However, the shortest path between “Tokyo” and one of its descendants, “Holladay”, has a much higher degree of seven.</p><p>Note that degree calculations in this case are not limited to one linear string of parent-child relationships; cousins and siblings and products thereof will also have computable degrees via nonlinear strings of parent-child relationships.</p></div><div id="functions-for-the-whole-tree" class="section level1"><h1>Functions for the Whole Tree</h1><p>There are many parameters about the tree that you may wish to know that cannot easily be obtained through images and tables. The function <strong>getBasicStatistics()</strong> will return graph theoretical measurements of the whole tree. For instance, is the whole tree connected? If not, how many separated components does it contain? In addition to these parameters, the <strong>getBasicStatistics()</strong> function will also return the number of nodes, the number of edges, the average path length, the graph diameter, among others:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getBasicStatistics(ig)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| $isConnected
#| [1] FALSE
#| 
#| $numComponents
#| [1] 11
#| 
#| $avePathLength
#| [1] 5.333746
#| 
#| $graphDiameter
#| [1] 13
#| 
#| $numNodes
#| [1] 230
#| 
#| $numEdges
#| [1] 340
#| 
#| $logN
#| [1] 5.438079
</code></pre></div></div><p>In this case, we learn that our tree is actually not all connected by parent-child edges, and that instead, it is composed of 11 separate components. We see that the average path length of the tree is 5.333, that the graph diameter is 13, and that the logN value is 5.438. We also see that the number of nodes in the tree is 230, and the number of edges in the tree is 340.</p><p>But can we view a list of these nodes and edges? To do so, we can call the <strong>getNodes()</strong> and <strong>getEdges()</strong> commands to obtain lists of all the unique nodes and edges in the tree. Here, we obtain a list of the 340 edges (with each row containing the names of the two connected vertices, and an edge weight, if existent). We will simply view the first six rows of the object, and determine the number of edges by counting the number of rows (340):</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">eList = getEdges(ig, sbTree)
head(eList)
dim(eList)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#|      child           parent     
#| [1,] "5601T"         "Hutcheson"
#| [2,] "Adams"         "Dunfield" 
#| [3,] "A.K. (Harrow)" "A.K."     
#| [4,] "Altona"        "Flambeau" 
#| [5,] "Amcor"         "Amsoy 71" 
#| [6,] "Amsoy"         "Adams"    
#| [1] 340   2
</code></pre></div></div><p>We then obtain a list of the 230 nodes. Again, we only view the first six rows of the object, and determine the number of nodes by counting the number of rows (230).</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">nList = getNodes(sbTree)
head(nList)
length(nList)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| [1] "5601T"         "Adams"         "A.K."          "A.K. (Harrow)"
#| [5] "Altona"        "Amcor"        
#| [1] 230
</code></pre></div></div></div><div id="visualizing-the-tree" class="section level1"><h1>Visualizing the Tree</h1><p>Until this point, the vignette has introduced functions that return lists, data frames, and statistics about the genealogical dataset. However, the <strong>phyViz</strong> package also contains visualization tools for genealogical datasets. Access to various types of visual plots and diagrams of the lineage can allow genealogical researchers to more efficiently and accurately explore an otherwise complicated data structure. Below, we introduce functions in <strong>phyViz</strong> that produce visual outputs of the dataset.</p><div id="plotting-the-ancestors-and-descendants-of-a-vertex" class="section level2"><h2>Plotting the Ancestors and Descendants of a Vertex</h2><p>One visualization tool, <strong>plotAncDes()</strong>, allows the user to view the ancestors and descendants of a given variety. The inputted variety is highlighted in the center of the plot, ancestors are displayed to the left of the center, and descendants are displayed to the right of the center. The further left or right from the center, the larger the number of generations that particular ancestor/descendant is from the inputted and centered variety.</p><p>As such, this plotting command does not provide visual information about specific years associated with each related variety (as is done in some of the visualization tools introduced later), but it does group all varieties from each generation group onto the same position of the horizontal axis. Here, we specify that we want to plot 5 ancestor generations and 3 descendant generations of the variety “Essex”:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">plotAncDes("Essex", sbTree, 5, 3)</code></pre></div><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-20-1.png" /> </a></div></div></div><p>We immediately see that this visual representation of the ancestors and descendants of a given variety can often provide enhanced readability compared to the list output provided in the previous similar functions, <strong>getAncestors()</strong> and <strong>getDescendants()</strong>.</p><p>We also see now that some node labels are repeated. For instance, the “5601T” variety appears twice, once as a grandchild (second generation descendant) of “Essex”, and once as a great-granchild (third generation descendant) of “Essex”. This is because there are two separate parent-child pathways between “Essex” and “5601T”, one pathway with only one node (“Hutchson”) between them, and one pathway with two nodes (“T80-69” and “TN89-39”) between them.</p><p>However, in this visual tool, we are constraining the horizontal axis to generation count. Without allowing nodes to repeat, this data information cannot be clearly and succinctly presented. Most graph visualization software that genealogists might use to view their datasets do not allow for repeated nodes, as per the definition of a graph. Hence, the <strong>plotAncDes()</strong> function is one of the more unique visual tools of the <strong>phyViz</strong> package.</p><p>It should be noted that the <strong>plotAncDes()</strong> function, by default, highlights the centered variety label in pink. However, the user can alter this color, as we will show below. Furthermore, the user can specify additional grammar of graphics plotting tools (from the <strong>ggplot2</strong> package) to tailor the output of the <strong>plotAncDes()</strong> function.</p><p>For example, we will now change the color of the center variety label <strong>vColor</strong> to be highlighted in blue. Also, we will add a horizontal axis label called “Generation index”, using the <strong>ggplot2</strong> syntax. Note that this time we do not specify the generational count for ancestors and descendants, and so the default value of three generations is applied for both cases. Remember, to determine such default values, as well as all possible function parameters, simply run the help command on the function of interest, as in help(plotAncDes).</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">plotAncDes("Tokyo", sbTree, vColor = "blue") + ggplot2::labs(x = "Generation index", 
    y = "")</code></pre></div><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-21-1.png" /> </a></div></div></div><p>We verify immediately that the “Tokyo” variety does not have any ancestors in this dataset, an observation consistent with what we discovered earlier. We also see the “Tokyo” variety only has two children, but has many more grandchildren, and great-grand children.</p></div><div id="plotting-the-path-between-two-vertices" class="section level2"><h2>Plotting the Path between Two Vertices</h2><p>As this data set deals with soy bean lineages, it may be useful for agronomists to track how two varieties are related to each other via parent-child relationships. Then, any dramatic changes in protein yield, SNP varieties, and other measures of interest between the two varieties can be tracked across their genetic timeline, and pinpointed to certain varieties within their historical lineage.</p><p>The <strong>phyViz</strong> software allows users to select two varieties of interest, and determine the shortest pathway of parent-child relationships between them, using the <strong>getPath()</strong> function. This will return a list path object that contains the variety names and their years in the path. The returned path object can then be plotted using the <strong>plotPath()</strong> function:</p><p>The <strong>getPath()</strong> function determines the shortest path between the two inputted vertices, and takes into account whether or not the graph is directed with the parameter <strong>isDirected</strong>, which defaults to false. The <strong>getPath()</strong> function will check both directions and return the path if it exists. Below, we look at all three possibilities (undirected and directed in reverse orders) between two varieties:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getPath("Brim", "Bedford", ig, sbTree, isDirected = FALSE)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| $pathVertices
#| [1] "Brim"    "Young"   "Essex"   "T80-69"  "J74-40"  "Forrest" "Bedford"
#| 
#| $yearVertices
#| [1] "1977" "1968" "1962" "1975" "1975" "1973" "1978"
</code></pre></div></div><p>We see that there is a path between “Brim” and “Bedford” varieties, with five varieties separating them. We are not considering direction, however, because the <strong>ig</strong> object is undirected.</p><p>However, to demonstrate the importance of direction, we will recompute the path where the direction matters. We first produce a directed igraph object <strong>dirIG</strong>, and then try to determine the path between the same two vertices, “Brim” and “Bedford”.</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">dirIG = treeToIG(sbTree, vertexinfo = nodes, isDirected = TRUE)
getPath("Brim", "Bedford", dirIG, sbTree, isDirected = TRUE)</code></pre></div><div class="panel panel-info"><button class="btn btn-default btn-xs btn-info"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="message r">#| Warning: There is no path between those two vertices
</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| list()
</code></pre></div></div><p>Now that we are considering the direction, we are only considering paths where each edge represents a parent-child relationship in the same direction as the one before it. We now receive an empty return list with a warning that there is no path between those two vertices. We next try to reverse the input order of the vertices, as shown below, but we will receive the same empty return list and warning:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getPath("Bedford", "Brim", dirIG, sbTree, isDirected = TRUE)</code></pre></div><div class="panel panel-info"><button class="btn btn-default btn-xs btn-info"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="message r">#| Warning: There is no path between those two vertices
</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| list()
</code></pre></div></div><p>We can derive from the empty list returned in the last two commands that the varieties “Brim” and “Bedford” are not connected by a linear sequence of parent-child relationships. Rather, the path between them branches at some point, involving siblings and/or cousins.</p><p>Hence, unless you are working with a dataset that must be analyzed as a directed graph, it is best to use the <strong>getPath()</strong> function with the default third parameter indicating lack of direction, and to use an <strong>igraph object</strong> without direction, such as <strong>ig</strong>. We do just that, and save the path between these two varieties to a variable called <strong>path</strong>:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">path = getPath("Bedford", "Brim", ig, sbTree, isDirected = FALSE)</code></pre></div></div><p>Now that we have a non-empty <strong>path</strong> object that consists of two lists (for variety names and years), we can plot the relationship between the two using the <strong>plotPath()</strong> function.</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">plotPath(path)</code></pre></div><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-26-1.png" /> </a></div></div></div><p>This produces a neat visual that informs us of all the varieties involved in the shortest path between “Brim” and “Bedford”. In this plot, the years of all varieties involved in the path are indicated on the horizontal axis, while the vertical axis has no meaning other than to simply to display the labels evenly spaced vertically.</p><p>Although a call to the phyViz function <strong>getYear()</strong> indicates that “Bedford”&quot; was developed in 1978 and “Brim” in 1977, we quickly determine from the plot that “Brim” is not a parent, grandparent, nor any great grandparent of “Bedford”. Instead, we see that these two varieties are not related through a unidirectional parent-child lineage, but have a cousin-like relationship. The oldest common ancestor between “Bedford” and “Brim” is the variety “Essex”, which was developed in 1962.</p><p>However, there are other cases of pairs of varieties that are connected by a linear, unidirectional combination of parent-child relationships, as we see below:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">path = getPath("Narow", "Tokyo", ig, sbTree, isDirected = FALSE)
plotPath(path)</code></pre></div><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-27-1.png" /> </a></div></div></div><p>Here, we see that the variety “Tokyo” is an ancestor of “Narow” via four linear parent-child relationships. Because of this, we can still view the pathway, even when we use an <strong>igraph</strong> object <strong>dirIG</strong> that is directed, and set the boolean <strong>isDirected</strong> variable to true. Either ordering of the two varieties will produce the exact same result:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">path = getPath("Narow", "Tokyo", dirIG, sbTree, isDirected = TRUE)
plotPathImage <- plotPath(path)

path = getPath("Tokyo", "Narow", dirIG, sbTree, isDirected = TRUE)
plotPathImage <- plotPath(path)</code></pre></div></div></div><div id="plotting-the-pathway-between-two-vertices-superimposed-on-tree" class="section level2"><h2>Plotting the Pathway between Two Vertices Superimposed on Tree</h2><p>Now that we can create and plot path objects, we may wish to know how those paths are positioned in comparison to the genealogical lineage of the entire data structure. For instance, of the documented soybean cultivar lineage varieties, where does the shortest path between two varieties of interest exist? Are these two varieties comparatively older compared to the overall data structure? Are they newer? Or, do they span the entire structure, and represent two extreme ends of documented time points?</p><p>There is a function available in the <strong>phyViz</strong> package, <strong>plotPathOnTree()</strong>, that allows users to quickly visualize their path of interest superimposed over all varieties and edges present in the whole data structure. Here we will produce a plot of the previously-determined shortest path between varieties Tokyo and Narow across the entire dataset:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">plotPathOnTree(path, sbTree, ig, binVector = 1:3)</code></pre></div><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-29-1.png" /> </a></div></div></div><p>While the first three explicit parameters to the function <strong>plotPathOnTree()</strong> have been introduced earlier in this paper, the fourth parameter (<strong>binVector</strong>) requires some explanation. The motivation of the <strong>plotPathOnTree()</strong> function is to write variety text labels on a plot, with the center of each variety label constricted on the horizontal axis to its developmental year. As is the case for the plots before, the vertical axis has no meaning other than pro- viding a plotting area in which to draw the text labels. Unfortunately, for large datasets, this motivation can be a difficult task because the text labels of the varieties can overlap if they are assigned a similar y coordinate, have a similar year (x coordinate), and have labels with large numbers of characters (width of x coordinate).</p><p>For each variety, the x coordinate (year) and width of the x coordinate (text label width) cannot be altered, as they provide useful information. However, for each variety, the vertical coordinate is arbitrary. Hence, in an attempt to mitigate text overlapping, the <strong>plotPathOnTree()</strong> function does not randomly assign the vertical coordinate. Instead, it allows users to partially control the vertical coordinates with a user-determined number of bins (<strong>binVector</strong>).</p><p>If the user determines to produce a plot using three bins, as in the example code above, then the varieties are all grouped into three bins based on their years of development. In other words, there will be bin 1 (the “oldest bin”) which includes one-third of the total number of varieties all with the oldest developmental years, bin 2 (the “middle bin”), and bin 3 (the “youngest bin”).</p><p>Then, in order to decrease text overlap, the consecutively increasing vertical axis coordinates are alternatively assigned to the three bins (For example: bin 1, then bin 2, then bin 3, then bin 1, then bin 2, then bin 3, etc.) repeatedly until all varieties are accounted. This algorithm means that for any pair of varieties within a given bin constrained to those years on the horizontal axis, there are exactly two other varieties placed between them vertically on the vertical axis that come from the two other bins constrained to a different set of year values on the horizontal axis.</p><p>We see in the plot that edges not on the path of interest are thin and gray, whereas edges on the path of interest are bolded and green, by default. We also see that variety labels in the path of interest are boldfaced, by default.</p><p>The plot presents useful information: We immediately gather that the path of interest between “Tokyo” and “Narow” does span most of the years of the data structure. In fact, Tokyo appears to be the oldest variety present in the dataset, and Narow appears to be one of the youngest varieties. We can also determine that the vast majority of varieties appear to have development years between 1950 and 1970.</p><p>However, this plot has significant empty spaces between the noticeably distinct bins, whereas almost all text labels are overlapping, thereby decreasing their readability. To force some variety text labels into these spaces, the user may consider using a larger number of bins. Hence, we next examine a <strong>binVector</strong> size of six:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">plotPathOnTree(path, sbTree, ig, binVector = 1:6)</code></pre></div><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-30-1.png" /> </a></div></div></div><p>We can immediately see that this plot more successfully mitigates text variety label overlap than the previous plot that had a <strong>binVector</strong> size of three. We can also confirm what we saw in the previous plot that indeed most varieties have development years between 1950 and 1970, and any remaining textual overlap is confined to this range of years.</p></div><div id="generating-a-pairwise-distance-matrix-between-set-of-vertices" class="section level2"><h2>Generating a Pairwise Distance Matrix between Set of Vertices</h2><p>It may also be of interest to generate matrices where the colors indicates a variable (such as the degree of the shortest path) between all pairwise combinations of inputted varieties. The package <strong>phyViz</strong> also provides a function <strong>plotDegMatrix()</strong> for that purpose.</p><p>Here we generate a distance matrix for a set of 8 varieties, defining the x-axis title and y-axis title as “Soybean label”, and the legend label as “Degree”. Syntax from the <strong>ggplot2</strong> package can be appended to tailor the output from the <strong>plotDegMatrix()</strong> function. In this case, we specify that pairs with small degrees are colored white, while pairs with large degrees are colored dark green:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">varieties = c("Brim", "Bedford", "Calland", "Narow", "Pella", "Tokyo", "Young", "Zane")
p = plotDegMatrix(varieties, ig, sbTree, "Soybean label", "Soybean label", "Degree")
p + ggplot2::scale_fill_continuous(low = "white", high = "darkgreen")</code></pre></div><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-31-1.png" /> </a></div></div></div><p>We see that the degree of the shortest path between varieties “Bedford” and “Zane” seems to be the largest in the dataset, which should be around 10. We can verify this simply with:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">getDegree("Bedford", "Zane", ig, sbTree)</code></pre></div><div class="panel panel-success"><button class="btn btn-default btn-xs btn-success"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="output r">#| [1] 10
</code></pre></div></div><p>Indeed, the degree of the shortest path between “Bedford” and “Zane” is 10. However, what the distance matrix additionally tells us is that a degree of 10 may be a comparatively large degree for this given soybean dataset, at least in that the degrees of the shortest paths for the other 27 pairwise combinations of varieties that we explored here are less than 10.</p><p>In a similar function, <strong>plotYearMatrix()</strong>, the difference in years between all pairwise combinations of vertices can be constructed and viewed:</p><div class="row"><div class="panel panel-primary"><button class="btn btn-default btn-xs btn-primary"><span class="glyphicon glyphicon-chevron-left"></span></button>

<pre ><code class="source r">varieties = c("Brim", "Bedford", "Calland", "Narow", "Pella", "Tokyo", "Young", "Zane")
plotYearMatrix(varieties, sbTree)</code></pre></div><div class="row"><div class="col-md-offset-3 col-md-6"><a href="#" class="thumbnail"><img src="phyViz_files/figure-html/unnamed-chunk-33-1.png" /> </a></div></div></div><p>Here, we did not change any defaults. As such, the x-axis and y-axis labels are the default value “Variety”, the legend key label is the default value “Difference in years”, and the default color of the matrix is dark blue for small year difference and light blue for large year difference.</p><p>Running this function on this particular set of vertices shows that most combinations of varieties are only one or two decades apart in year introduction, with the exception of the “Tokyo” variety, which appears to be separated from each of the other seven varities by about six decades. This should not be too surprising, because we have seen througout the tutorial that the “Tokyo” variety is the oldest variety in the dataset.</p></div></div><div id="conclusion" class="section level1"><h1>Conclusion</h1><p>The phyViz package offers various plotting tools that can assist those studying genealogical lineages in the data exploration phases. As each plot comes with its pros and cons, we recommend for users to explore several of the available visualization tools.</p></div>

          <p class="text-muted" id="credit">
            Styled with <a href="https://github.com/jimhester/knitrBootstrap">knitrBootstrap</a>
          </p>

        </div>

        
      </div>
    </div>

        <!-- dynamically load mathjax for compatibility with self-contained -->
    <script>
      (function () {
          var script = document.createElement("script");
          script.type = "text/javascript";
          script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
          document.getElementsByTagName("head")[0].appendChild(script);
      })();
    </script>
      </body>
</html>
